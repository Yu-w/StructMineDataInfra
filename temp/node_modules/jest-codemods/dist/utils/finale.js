'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = finale;

var _consts = require('./consts');

var _imports = require('./imports');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _proxyquire = require('./proxyquire');

var _proxyquire2 = _interopRequireDefault(_proxyquire);

var _quoteStyle = require('./quote-style');

var _quoteStyle2 = _interopRequireDefault(_quoteStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function detectIncompatiblePackages(fileInfo, j, ast) {
    ['sinon', 'testdouble'].forEach(pkg => {
        if ((0, _imports.hasRequireOrImport)(j, ast, pkg)) {
            (0, _logger2.default)(fileInfo, `Usage of package "${pkg}" might be incompatible with Jest`);
        }
    });
}

function updateJestImports(j, ast, isStandaloneMode) {
    let testFunctionName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'jest';

    const addRequireOrImportOnce = (0, _imports.addRequireOrImportOnceFactory)(j, ast);

    if (isStandaloneMode && !(0, _imports.hasRequireOrImport)(j, ast, 'expect')) {
        addRequireOrImportOnce('expect', 'expect');
    }

    ast.find(j.CallExpression, {
        callee: {
            type: 'MemberExpression',
            object: { type: 'Identifier', name: testFunctionName },
            property: { name: p => _consts.JEST_MOCK_PROPERTIES.has(p) }
        }
    }).forEach(path => {
        const callee = path.node.callee;

        if (isStandaloneMode) {
            const mockLocalName = 'mock';
            addRequireOrImportOnce(mockLocalName, 'jest-mock');
            callee.object = mockLocalName;
        } else {
            callee.object = 'jest';
        }
    });
}

/**
 * Exposes the finale shared by all transformers.
 * @return the ast.toSource that should be returned to jscodeshift.
 */
function finale(fileInfo, j, ast, transformerOptions, testFunctionName) {
    const standaloneMode = transformerOptions.standaloneMode;


    detectIncompatiblePackages(fileInfo, j, ast);
    updateJestImports(j, ast, standaloneMode, testFunctionName);
    (0, _proxyquire2.default)(fileInfo, j, ast);

    // As Recast is not preserving original quoting, we try to detect it,
    // and default to something sane.
    const quote = (0, _quoteStyle2.default)(j, ast) || 'single';
    return ast.toSource({ quote: quote });
}