'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getIdentifierFromExpression = getIdentifierFromExpression;
exports.getMemberExpressionElements = getMemberExpressionElements;
exports.findParentCallExpression = findParentCallExpression;
exports.findParentVariableDeclaration = findParentVariableDeclaration;
exports.findParentOfType = findParentOfType;
exports.traverseMemberExpressionUtil = traverseMemberExpressionUtil;
/**
 * Find the identifier from a given MemberExpression
 *
 * Example: return `foo` for a node of `foo.bar.baz()`
 *
 * @param  {MemberExpression} node
 * @return {string|null}
 */
function getIdentifierFromExpression(node) {
    if (!node) {
        return null;
    }
    if (node.type === 'Identifier') {
        return node;
    }
    return getIdentifierFromExpression(node.object);
}

/**
 * Returns list of elements from a given MemberExpression
 *
 * Example: return ['foo', 'bar', 'baz'] for a node of `foo.bar.baz()`
 *
 * @param  {MemberExpression} node
 * @return {array}
 */
function getMemberExpressionElements(node) {
    let _rest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (node.object.type === 'Identifier') {
        return [node.object.name, node.property.name].concat(_rest);
    }
    return getMemberExpressionElements(node.object, [node.property.name].concat(_rest));
}

function findParentCallExpression(path, name) {
    if (!path) {
        return null;
    }
    if (path.value.type === 'CallExpression' && path.value.callee.property && path.value.callee.property.name === name) {
        return path;
    }
    return findParentCallExpression(path.parentPath, name);
}

function findParentVariableDeclaration(path) {
    return findParentOfType(path, 'VariableDeclarator');
}

function findParentOfType(path, type) {
    if (!path || !path.value) {
        return null;
    }
    if (path.value.type === type) {
        return path;
    }
    return findParentOfType(path.parentPath, type);
}

function traverseMemberExpressionUtil(j, nodeValidator) {
    const traverseMemberExpression = node => {
        if (!node) {
            return false;
        }

        if (nodeValidator(node)) {
            return true;
        }

        return traverseMemberExpression(node.object);
    };

    return traverseMemberExpression;
}