'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = mochaToJest;

var _finale = require('../utils/finale');

var _finale2 = _interopRequireDefault(_finale);

var _jasmineThis = require('./jasmine-this');

var _jasmineThis2 = _interopRequireDefault(_jasmineThis);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const methodMap = {
    suite: 'describe',
    context: 'describe',
    specify: 'test',
    test: 'test',
    it: 'test',
    before: 'beforeAll',
    beforeEach: 'beforeEach',
    setup: 'beforeEach',
    after: 'afterAll',
    afterEach: 'afterEach',
    teardown: 'afterEach',
    suiteSetup: 'beforeAll',
    suiteTeardown: 'afterAll'
};

const jestMethodsWithDescriptionsAllowed = new Set(['test', 'describe']);

const methodModifiers = ['only', 'skip'];

function hasBinding(name, scope) {
    if (!scope) {
        return false;
    }

    const bindings = Object.keys(scope.getBindings()) || [];
    if (bindings.indexOf(name) >= 0) {
        return true;
    }

    return scope.isGlobal ? false : hasBinding(name, scope.parent);
}

function mochaToJest(fileInfo, api, options) {
    const j = api.jscodeshift;
    const ast = j(fileInfo.source);

    Object.keys(methodMap).forEach(mochaMethod => {
        const jestMethod = methodMap[mochaMethod];

        ast.find(j.CallExpression, {
            type: 'CallExpression',
            callee: { type: 'Identifier', name: mochaMethod }
        }).filter((_ref) => {
            let scope = _ref.scope;
            return !hasBinding(mochaMethod, scope);
        }).replaceWith(path => {
            let args = path.value.arguments;
            if (!jestMethodsWithDescriptionsAllowed.has(jestMethod)) {
                args = args.filter(a => a.type !== 'Literal');
            }
            return j.callExpression(j.identifier(jestMethod), args);
        });

        methodModifiers.forEach(modifier => {
            ast.find(j.CallExpression, {
                type: 'CallExpression',
                callee: {
                    type: 'MemberExpression',
                    object: { type: 'Identifier', name: mochaMethod },
                    property: { type: 'Identifier', name: modifier }
                }
            }).replaceWith(path => j.callExpression(j.memberExpression(j.identifier(jestMethod), j.identifier(modifier)), path.value.arguments));
        });
    });

    fileInfo.source = (0, _finale2.default)(fileInfo, j, ast, options);

    const transformedSource = (0, _jasmineThis2.default)(fileInfo, api, options);
    if (transformedSource) {
        fileInfo.source = transformedSource;
    }

    return fileInfo.source;
}