'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = avaToJest;

var _imports = require('../utils/imports');

var _consts = require('../utils/consts');

var _tapeAvaHelpers = require('../utils/tape-ava-helpers');

var _recastHelpers = require('../utils/recast-helpers');

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _finale = require('../utils/finale');

var _finale2 = _interopRequireDefault(_finale);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Codemod for transforming AVA tests into Jest.
 */

const SPECIAL_THROWS_CASE = '(special throws case)';
const SPECIAL_BOOL = '(special bool case)';
const SPECIAL_PLAN_CASE = '(special plan case)';

const tPropertiesMap = {
    ok: 'toBeTruthy',
    truthy: 'toBeTruthy',
    falsy: 'toBeFalsy',
    notOk: 'toBeFalsy',
    true: SPECIAL_BOOL,
    false: SPECIAL_BOOL,
    is: 'toBe',
    not: 'not.toBe',
    same: 'toEqual',
    deepEqual: 'toEqual',
    notSame: 'not.toEqual',
    notDeepEqual: 'not.toEqual',
    throws: SPECIAL_THROWS_CASE,
    notThrows: SPECIAL_THROWS_CASE,
    regex: 'toMatch',
    notRegex: 'not.toMatch',
    ifError: 'toBeFalsy',
    error: 'toBeFalsy',
    plan: SPECIAL_PLAN_CASE,
    snapshot: 'toMatchSnapshot'
};

const tPropertiesNotMapped = new Set(['end', 'fail', 'pass']);

const avaToJestMethods = {
    before: 'beforeAll',
    after: 'afterAll',
    beforeEach: 'beforeEach',
    afterEach: 'afterEach',
    skip: 'test.skip',
    only: 'test.only'
};

function avaToJest(fileInfo, api, options) {
    const j = api.jscodeshift;
    const ast = j(fileInfo.source);

    const testFunctionName = (0, _imports.removeRequireAndImport)(j, ast, 'ava');

    if (!testFunctionName) {
        // No AVA require/import were found
        return fileInfo.source;
    }

    const logWarning = (msg, node) => (0, _logger2.default)(fileInfo, msg, node);

    const transforms = [() => (0, _tapeAvaHelpers.rewriteDestructuredTArgument)(fileInfo, j, ast, testFunctionName), () => (0, _tapeAvaHelpers.detectUnsupportedNaming)(fileInfo, j, ast, testFunctionName), function updateAssertions() {
        ast.find(j.CallExpression, {
            callee: {
                object: { name: 't' },
                property: (_ref) => {
                    let name = _ref.name;
                    return !tPropertiesNotMapped.has(name);
                }
            }
        }).forEach(p => {
            const args = p.node.arguments;
            const oldPropertyName = p.value.callee.property.name;
            const newPropertyName = tPropertiesMap[oldPropertyName];
            if (typeof newPropertyName === 'undefined') {
                logWarning(`"t.${oldPropertyName}" is currently not supported`, p);
                return null;
            }

            let newCondition;
            if (newPropertyName === SPECIAL_BOOL) {
                newCondition = j.callExpression(j.identifier('toBe'), [j.identifier(oldPropertyName)]);
            } else if (newPropertyName === SPECIAL_PLAN_CASE) {
                const condition = j.memberExpression(j.identifier('expect'), j.callExpression(j.identifier('assertions'), [args[0]]));
                return j(p).replaceWith(condition);
            } else if (newPropertyName === SPECIAL_THROWS_CASE) {
                if (args.length === 1) {
                    newCondition = j.callExpression(j.identifier(oldPropertyName === 'throws' ? 'toThrow' : 'not.toThrow'), []);
                } else {
                    newCondition = j.callExpression(j.identifier(oldPropertyName === 'throws' ? 'toThrowError' : 'not.toThrowError'), [args[1]]);
                }
            } else {
                const hasSecondArgument = _consts.PROP_WITH_SECONDS_ARGS.indexOf(newPropertyName) >= 0;
                const conditionArgs = hasSecondArgument ? [args[1]] : [];
                newCondition = j.callExpression(j.identifier(newPropertyName), conditionArgs);
            }

            const newExpression = j.memberExpression(j.callExpression(j.identifier('expect'), [args[0]]), newCondition);

            return j(p).replaceWith(newExpression);
        });
    }, function rewriteTestCallExpression() {
        // Can either be simple CallExpression like test()
        // Or MemberExpression like test.after.skip()

        ast.find(j.CallExpression, {
            callee: { name: testFunctionName }
        }).forEach(p => {
            p.node.callee.name = 'test';
            (0, _tapeAvaHelpers.rewriteAssertionsAndTestArgument)(j, p);
        });

        function mapPathToJestMethod(p) {
            let jestMethod = 'test';

            // List like ['test', 'serial', 'cb']
            const avaMethods = (0, _recastHelpers.getMemberExpressionElements)(p.node.callee).filter(e => e !== 'serial' && e !== testFunctionName && e !== 'cb');

            if (avaMethods.length === 1) {
                const avaMethod = avaMethods[0];
                if (avaMethod in avaToJestMethods) {
                    jestMethod = avaToJestMethods[avaMethod];
                } else {
                    jestMethod = avaMethod;
                    logWarning(`Unknown AVA method "${avaMethod}"`, p);
                }
            } else if (avaMethods.length > 0) {
                logWarning('Skipping setup/teardown hooks is currently not supported', p);
            }

            return jestMethod;
        }

        ast.find(j.CallExpression, {
            callee: {
                type: 'MemberExpression'
            }
        }).filter(p => {
            const identifier = (0, _recastHelpers.getIdentifierFromExpression)(p.node.callee);
            if (identifier === null) {
                return null;
            }
            if (identifier.name === testFunctionName) {
                return p;
            }
            return null;
        }).forEach(p => {
            (0, _tapeAvaHelpers.rewriteAssertionsAndTestArgument)(j, p);
        }).replaceWith(p => j.callExpression(j.identifier(mapPathToJestMethod(p)), p.node.arguments));
    }];

    transforms.forEach(t => t());

    return (0, _finale2.default)(fileInfo, j, ast, options);
}