'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertPrefixes = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _chaiChainUtils = require('../utils/chai-chain-utils');

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _imports = require('../utils/imports');

var _recastHelpers = require('../utils/recast-helpers');

var _finale = require('../utils/finale');

var _finale2 = _interopRequireDefault(_finale);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const fns = ['keys', 'a', 'an', 'instanceof', 'lengthof', 'length', 'equal', 'throw', 'include', 'contain', 'eql', 'above', 'least', 'below', 'lessthan', 'most', 'match', 'string', 'members', 'property', 'ownproperty', 'ownpropertydescriptor', 'gte', 'lte', 'within'];

const members = ['ok', 'true', 'false', 'extensible', 'finite', 'frozen', 'sealed', 'null', 'undefined', 'exist', 'empty', 'nan', 'defined'];

const unsupportedProperties = new Set(['arguments', 'respondTo', 'satisfy', 'closeTo', 'oneOf', 'change', 'increase', 'decrease']);

const mapValueNameToObjectMethod = {
    extensible: 'isExtensible',
    frozen: 'isFrozen',
    sealed: 'isSealed'
};

const assertPrefixes = exports.assertPrefixes = new Set(['to', 'with', 'that']);

module.exports = function transformer(fileInfo, api, options) {
    const j = api.jscodeshift;
    const root = j(fileInfo.source);
    let mutations = 0;

    const createCall = (0, _chaiChainUtils.createCallUtil)(j);
    const chainContains = (0, _chaiChainUtils.chainContainsUtil)(j);
    const getAllBefore = (0, _chaiChainUtils.getNodeBeforeMemberExpressionUtil)(j);
    const updateExpect = (0, _chaiChainUtils.updateExpectUtil)(j);
    const createCallChain = (0, _chaiChainUtils.createCallChainUtil)(j);

    (0, _imports.removeRequireAndImport)(j, root, 'chai', 'expect');
    (0, _imports.removeRequireAndImport)(j, root, 'chai', 'should');
    // Not sure if expect is always imported... So we continue with the transformation:

    const isExpectCall = node => node.name === 'expect' || node.type === j.MemberExpression.name && isExpectCall(node.object) || node.type === j.CallExpression.name && isExpectCall(node.callee);

    const isShouldMemberExpression = (0, _recastHelpers.traverseMemberExpressionUtil)(j, node => node.type === 'Identifier' && node.name === 'should');

    const isExpectMemberExpression = (0, _recastHelpers.traverseMemberExpressionUtil)(j, node => node.type === j.CallExpression.name && node.callee.name === 'expect');

    const logWarning = (msg, node) => (0, _logger2.default)(fileInfo, msg, node);

    const typeOf = (value, args, containsNot) => {
        switch (args[0].value) {
            case 'null':
                return createCall('toBeNull', [], updateExpect(value, node => node, containsNot));
            case 'undefined':
                return createCall('toBeUndefined', [], updateExpect(value, node => node, containsNot));
            case 'array':
                return createCall('toBe', [j.booleanLiteral(containsNot ? false : true)], updateExpect(value, node => j.callExpression(j.memberExpression(j.identifier('Array'), j.identifier('isArray')), [node])));
            default:
                return createCall('toBe', args, updateExpect(value, node => j.unaryExpression('typeof', node)), containsNot);
        }
    };

    // TODO: not sure if this is even required for chai...
    // E.g. is should(x).true valid?
    const isPrefix = name => assertPrefixes.has(name);

    function parseArgs(args) {
        if (args.length === 1 && args[0].type === j.ObjectExpression.name) {
            return [createCallChain(['Object', 'keys'], args)];
        } else if (args.length > 1) {
            return [j.arrayExpression(args)];
        }

        return args;
    }

    function containing(node) {
        switch (node.type) {
            case j.ArrayExpression.name:
                return createCallChain(['expect', 'arrayContaining'], [node]);
            case j.ObjectExpression.name:
                return createCallChain(['expect', 'objectContaining'], [node]);
            default:
                return node;
        }
    }

    function getRestWithLengthHandled(p, rest) {
        const containsLength = chainContains('length', p.value.callee, isPrefix);
        return containsLength ? updateExpect(rest, node => j.memberExpression(node, j.identifier('length'))) : rest;
    }

    function withIn(p, rest, args, containsNot) {
        if (args.length < 2) {
            logWarning(`.within needs at least two arguments`, p);
            return p.value;
        }

        j(p).closest(j.ExpressionStatement).insertBefore(j.expressionStatement(createCall('toBeLessThanOrEqual', [args[0]], rest, containsNot)));

        return createCall('toBeGreaterThanOrEqual', [args[1]], rest, containsNot);
    }

    const shouldChainedToExpect = () => root.find(j.MemberExpression, {
        property: {
            type: j.Identifier.name,
            name: 'should'
        }
    }).replaceWith(p => j.callExpression(j.identifier('expect'), [p.node.object])).size();

    const shouldIdentifierToExpect = () => root.find(j.CallExpression).filter(p => isShouldMemberExpression(p.value.callee)).replaceWith(p => {
        const callee = p.value.callee;

        var _p$node$arguments = _slicedToArray(p.node.arguments, 2);

        const args0 = _p$node$arguments[0],
              args1 = _p$node$arguments[1];


        const assertionNode = j.identifier(callee.property.name);
        const assertionPrefixNode = callee.object.property;
        const firstChainElement = assertionPrefixNode || assertionNode;

        let memberExpression = j.memberExpression(j.callExpression(j.identifier('expect'), [args0]), firstChainElement);

        if (assertionPrefixNode) {
            // if there is a .not wrap it in another memberExpression
            memberExpression = j.memberExpression(memberExpression, assertionNode);
        }

        if (typeof args1 === 'undefined') {
            return memberExpression;
        }

        return j.callExpression(memberExpression, [args1]);
    }).size();

    const updateMemberExpressions = () => {
        const getMembers = () => root.find(j.MemberExpression, {
            property: {
                name: _name => members.indexOf(_name.toLowerCase()) !== -1
            }
        }).filter(p => (0, _recastHelpers.findParentOfType)(p, 'ExpressionStatement'));

        getMembers().forEach(p => {
            if (p.parentPath.value.type === j.CallExpression.name) {
                p.parentPath.replace(p.value);
            }
        });

        return getMembers().replaceWith(p => {
            const value = p.value;

            const rest = getAllBefore(isPrefix, value, 'should');
            const containsNot = chainContains('not', value, 'to');

            const propertyName = value.property.name.toLowerCase();

            switch (propertyName) {
                case 'ok':
                    return containsNot ? createCall('toBeFalsy', [], rest) : createCall('toBeTruthy', [], rest);
                case 'true':
                    return createCall('toBe', [j.booleanLiteral(true)], rest, containsNot);
                case 'false':
                    return createCall('toBe', [j.booleanLiteral(false)], rest, containsNot);
                case 'finite':
                    return createCall('toBe', [j.booleanLiteral(!containsNot)], updateExpect(value, node => {
                        return createCallChain(['isFinite'], [node]);
                    }));
                case 'extensible':
                case 'frozen':
                case 'sealed':
                    return createCall('toBe', [j.booleanLiteral(!containsNot)], updateExpect(value, node => {
                        return createCallChain(['Object', mapValueNameToObjectMethod[propertyName]], [node]);
                    }));
                case 'null':
                    return createCall('toBeNull', [], rest, containsNot);
                case 'nan':
                    return createCall('toBeNaN', [], rest, containsNot);
                case 'undefined':
                    return containsNot ? createCall('toBeDefined', [], rest) : createCall('toBeUndefined', [], rest);
                case 'empty':
                    return createCall('toHaveLength', [j.literal(0)], updateExpect(value, node => {
                        if (node.type === j.ObjectExpression.name || node.type === j.Identifier.name) {
                            return createCallChain(['Object', 'keys'], [node]);
                        }
                        return node;
                    }), containsNot);
                case 'exist':
                case 'defined':
                    return containsNot ? createCall('toBeFalsy', [], rest) : createCall('toBeDefined', [], rest);
                default:
                    return value;
            }
        }).size();
    };

    const updateCallExpressions = () => root.find(j.CallExpression, {
        callee: {
            type: j.MemberExpression.name,
            property: {
                name: _name2 => fns.indexOf(_name2.toLowerCase()) !== -1
            },
            object: isExpectCall
        }
    }).replaceWith(p => {
        const value = p.value;


        const restRaw = getAllBefore(isPrefix, value.callee, 'should');
        const rest = getRestWithLengthHandled(p, restRaw);
        const containsNot = chainContains('not', value.callee, isPrefix);
        const containsDeep = chainContains('deep', value.callee, isPrefix);
        const containsAny = chainContains('any', value.callee, isPrefix);
        const args = value.arguments;

        switch (p.value.callee.property.name.toLowerCase()) {
            case 'equal':
                return containsDeep ? createCall('toEqual', args, rest, containsNot) : createCall('toBe', args, rest, containsNot);
            case 'throw':
                return createCall('toThrowError', args, rest, containsNot);
            case 'include':
            case 'string':
            case 'contain':
                if (args.length === 1 && args[0].type === j.ObjectExpression.name) {
                    return createCall('toMatchObject', args, rest, containsNot);
                }
                return createCall('toContain', args, rest, containsNot);
            case 'eql':
                return createCall('toEqual', args, rest, containsNot);
            case 'above':
                return createCall('toBeGreaterThan', args, rest, containsNot);
            case 'least':
            case 'gte':
                return createCall('toBeGreaterThanOrEqual', args, rest, containsNot);
            case 'below':
            case 'lessthan':
                return createCall('toBeLessThan', args, rest, containsNot);
            case 'most':
            case 'lte':
                return createCall('toBeLessThanOrEqual', args, rest, containsNot);
            case 'within':
                return withIn(p, rest, args, containsNot);
            case 'match':
                return createCall('toMatch', args, rest, containsNot);
            case 'members':
                if (chainContains('ordered', value.callee, isPrefix)) {
                    logWarning('Unsupported Chai Assertion "ordered"', p);
                }

                return createCall('toEqual', args.map(containing), rest, containsNot);
            case 'keys':
                if (containsAny) {
                    logWarning('Unsupported Chai Assertion "any.keys"', p);
                    return value;
                }
                return createCall('toEqual', [createCallChain(['expect', 'arrayContaining'], parseArgs(args))], updateExpect(value, node => {
                    if (node.type === j.ObjectExpression.name) {
                        return createCallChain(['Object', 'keys'], [node]);
                    }
                    return node;
                }), containsNot);
            case 'a':
            case 'an':
                if (!args.length) {
                    return value;
                }
                if (args[0].type === 'Literal') {
                    return typeOf(value, args, containsNot);
                }
                return createCall('toBeInstanceOf', args, rest, containsNot);
            case 'instanceof':
                return createCall('toBeInstanceOf', args, rest, containsNot);
            case 'length':
            case 'lengthof':
                return createCall('toHaveLength', args, restRaw, containsNot);
            case 'property':
                return createCall('toHaveProperty', args, rest, containsNot);
            case 'ownproperty':
                return createCall('toBeTruthy', [], updateExpect(value, node => j.callExpression(j.memberExpression(node, j.identifier('hasOwnProperty')), [args[0]])));
            case 'ownpropertydescriptor':
                return args.length === 1 ? createCall('toBeUndefined', [], updateExpect(value, node => j.callExpression(j.memberExpression(j.identifier('Object'), j.identifier('getOwnPropertyDescriptor')), [node, args[0]])), true) : createCall('toEqual', [args[1]], updateExpect(value, node => j.callExpression(j.memberExpression(j.identifier('Object'), j.identifier('getOwnPropertyDescriptor')), [node, args[0]])));
            default:
                return value;
        }
    }).size();

    mutations += shouldChainedToExpect();
    mutations += shouldIdentifierToExpect();
    mutations += updateCallExpressions();
    mutations += updateMemberExpressions();

    root.find(j.MemberExpression, {
        property: {
            name: _name3 => unsupportedProperties.has(_name3)
        }
    }).filter(p => isExpectMemberExpression(p.value)).forEach(p => {
        const assertion = p.value.property.name;
        logWarning(`Unsupported Chai Assertion "${assertion}"`, p);
    });

    if (!mutations) {
        return null;
    }

    return (0, _finale2.default)(fileInfo, j, root, options);
};