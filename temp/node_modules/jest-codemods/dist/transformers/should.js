'use strict';

var _imports = require('../utils/imports');

var _recastHelpers = require('../utils/recast-helpers');

var _quoteStyle = require('../utils/quote-style');

var _quoteStyle2 = _interopRequireDefault(_quoteStyle);

var _chaiShould = require('./chai-should');

var _chaiShould2 = _interopRequireDefault(_chaiShould);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const assertionRemappings = {
    throws: 'throw'
};

module.exports = function transformer(fileInfo, api, options) {
    const j = api.jscodeshift;
    const root = j(fileInfo.source);

    const isShouldMemberExpression = (0, _recastHelpers.traverseMemberExpressionUtil)(j, node => node.type === j.CallExpression.name && node.callee.name === 'should' || node.type === j.Identifier.name && node.name === 'should');

    /**
     * Injects missing to prefixes expected by chai-should transformer.
     * TODO: not sure if this is even required for chai...
     */
    function injectMissingPrefix() {
        const injector = p => {
            const property = p.parentPath.value.property;

            if (property && property.type === j.Identifier.name) {
                if (property.name !== 'to') {
                    const newPath = j.memberExpression(p.value, j.identifier('to'));
                    p.replace(newPath);
                }
            }
        };

        root.find(j.CallExpression, {
            callee: {
                name: _name => ['expect', 'should'].indexOf(_name) >= 0
            }
        }).forEach(injector);

        root.find(j.MemberExpression, {
            property: {
                type: j.Identifier.name,
                name: 'should'
            }
        }).forEach(injector);
    }

    function renameShouldCallExpressions() {
        root.find(j.CallExpression, {
            callee: {
                name: 'should'
            }
        }).forEach(p => {
            p.value.callee.name = 'expect';
        });
    }

    function remapAssertions() {
        root.find(j.MemberExpression, {
            property: {
                name: _name2 => Object.keys(assertionRemappings).indexOf(_name2) >= 0
            }
        }).filter(p => isShouldMemberExpression(p.value)).forEach(p => {
            const property = p.value.property;

            property.name = assertionRemappings[property.name];
        });
    }

    (0, _imports.removeRequireAndImport)(j, root, 'should');
    injectMissingPrefix();
    renameShouldCallExpressions();
    remapAssertions();

    const quote = (0, _quoteStyle2.default)(j, root) || 'single';
    fileInfo.source = root.toSource({ quote: quote });

    return (0, _chaiShould2.default)(fileInfo, api, options);
};